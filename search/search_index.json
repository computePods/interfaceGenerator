{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ComputePods interface generator design The ComputePods interface generator is used to generate a collection of RESTful (HTTP) as well as NATS (publish/subscribe and request/response) interfaces. All of these interfaces will use JSON payloads . It uses a Literate definition style based upon a mixture of Markdown and YAML formatted files. The design of the interface format can be found here. The design of the interface generation, using Jinja2 templates, can be found here.","title":"ComputePods interface generator design"},{"location":"#computepods-interface-generator-design","text":"The ComputePods interface generator is used to generate a collection of RESTful (HTTP) as well as NATS (publish/subscribe and request/response) interfaces. All of these interfaces will use JSON payloads . It uses a Literate definition style based upon a mixture of Markdown and YAML formatted files. The design of the interface format can be found here. The design of the interface generation, using Jinja2 templates, can be found here.","title":"ComputePods interface generator design"},{"location":"Config/","text":"ComputePods interface generator configuration The ComputePods interface generator is primarily configured using a YAML configuration file. By default this configuration file is called cpigConfig.yaml in the directory in which the tool is started. Alternatively you can use the -c or --config command line option to specify a different configuration file. This configuration file works by having or not having one or more hierarchies of values located as sub-hierarchies of one of the top-level keys: genSchema , genExamples , genHttpRoutes , options . Controlling where the output code files go To specify the directory in which to place output code add the following key: options: output: <aPath> where <aPath is either an absolute path in your file system, or a path relative to the current working directory (in which you run the tool). Producing Pydantic/Python classes To produce Pydantic data classes for use in Python code add the following keys: genSchema: pydantic: <aCollectionOfKey>: <valuePairs> You can use any of the datamodel-code-generator command line options in the above collection of key/value pairs. If the option takes no arguments, then simply leave the value empty. (Note that any of the \"input\" options will be ignored as the input is controlled by the interface generator itself). If you just want to use the standard defaults they add the following keys: genSchema: pydantic: {} Producing AJV/JavaScript classes To produce AJV parsing / validation / serialisation code for use in JavaScript (either on the server or in the browser) add the following keys: genSchema: ajv: jinja2: ./templates/ajv.j2 ajvOptions: strict: True allErrors: True You can use either or both of the parse or serialize keywords. The you can use any of the AJV options in the options dictionary. Producing JSON examples for use in JavaScript To produce JSON examples for use in JavaScript add the following keys: genExamples: javaScriptExamples: jinja2: ./templates/jsExamples.j2 options: key: value Producing JSON examples for use in Python To produce JSON examples for use in Python add the following keys: genExamples: pythonExamples: jinja2: ./templates/pyExamples.j2 options: key: value Producing Mock Service Workers for use in JavaScript To produce Mock Service Workers code from the httpRoutes and jsonExamples then add the following keys: genExamples: mockServiceWorkers: jinja2: ./templates/msw.j2 options: key: value Producing Mithril connector mixin components for use in JavaScript To produce Mithril connector mixin components code from the httpRoutes then add the following keys: genHttpRoutes: mithrilConnectors: jinja2: ./templates/mithrilConnectors.j2 options: key: value Full example with Pydantic defaults To produce all of the output using the Pydantic defaults use the following configuration file: options: output: aPath genSchema: pydantic: {} ajv: ajvOptions: strict: True allErrors: True genExamples: javaScriptExamples: {} pythonExamples: {} mockServiceWorkers: {} genHttpRoutes: mithrilConnectors: {}","title":"ComputePods interface generator configuration"},{"location":"Config/#computepods-interface-generator-configuration","text":"The ComputePods interface generator is primarily configured using a YAML configuration file. By default this configuration file is called cpigConfig.yaml in the directory in which the tool is started. Alternatively you can use the -c or --config command line option to specify a different configuration file. This configuration file works by having or not having one or more hierarchies of values located as sub-hierarchies of one of the top-level keys: genSchema , genExamples , genHttpRoutes , options .","title":"ComputePods interface generator configuration"},{"location":"Config/#controlling-where-the-output-code-files-go","text":"To specify the directory in which to place output code add the following key: options: output: <aPath> where <aPath is either an absolute path in your file system, or a path relative to the current working directory (in which you run the tool).","title":"Controlling where the output code files go"},{"location":"Config/#producing-pydanticpython-classes","text":"To produce Pydantic data classes for use in Python code add the following keys: genSchema: pydantic: <aCollectionOfKey>: <valuePairs> You can use any of the datamodel-code-generator command line options in the above collection of key/value pairs. If the option takes no arguments, then simply leave the value empty. (Note that any of the \"input\" options will be ignored as the input is controlled by the interface generator itself). If you just want to use the standard defaults they add the following keys: genSchema: pydantic: {}","title":"Producing Pydantic/Python classes"},{"location":"Config/#producing-ajvjavascript-classes","text":"To produce AJV parsing / validation / serialisation code for use in JavaScript (either on the server or in the browser) add the following keys: genSchema: ajv: jinja2: ./templates/ajv.j2 ajvOptions: strict: True allErrors: True You can use either or both of the parse or serialize keywords. The you can use any of the AJV options in the options dictionary.","title":"Producing AJV/JavaScript classes"},{"location":"Config/#producing-json-examples-for-use-in-javascript","text":"To produce JSON examples for use in JavaScript add the following keys: genExamples: javaScriptExamples: jinja2: ./templates/jsExamples.j2 options: key: value","title":"Producing JSON examples for use in JavaScript"},{"location":"Config/#producing-json-examples-for-use-in-python","text":"To produce JSON examples for use in Python add the following keys: genExamples: pythonExamples: jinja2: ./templates/pyExamples.j2 options: key: value","title":"Producing JSON examples for use in Python"},{"location":"Config/#producing-mock-service-workers-for-use-in-javascript","text":"To produce Mock Service Workers code from the httpRoutes and jsonExamples then add the following keys: genExamples: mockServiceWorkers: jinja2: ./templates/msw.j2 options: key: value","title":"Producing Mock Service Workers for use in JavaScript"},{"location":"Config/#producing-mithril-connector-mixin-components-for-use-in-javascript","text":"To produce Mithril connector mixin components code from the httpRoutes then add the following keys: genHttpRoutes: mithrilConnectors: jinja2: ./templates/mithrilConnectors.j2 options: key: value","title":"Producing Mithril connector mixin components for use in JavaScript"},{"location":"Config/#full-example-with-pydantic-defaults","text":"To produce all of the output using the Pydantic defaults use the following configuration file: options: output: aPath genSchema: pydantic: {} ajv: ajvOptions: strict: True allErrors: True genExamples: javaScriptExamples: {} pythonExamples: {} mockServiceWorkers: {} genHttpRoutes: mithrilConnectors: {}","title":"Full example with Pydantic defaults"},{"location":"Generation/","text":"ComputePods interface generation design Once the description of an interface has been loaded, the interface generator tool uses Jinja2 templates to generate various interface code files. At the moment the interface generator generates the follow types of code: JSON type definition in Python pydantic format using datamodel-code-generator Consider using the companion fastapi-code-generator JSON example data in Python format JSON type definition in JavaScript formatted using AJV JSON example data in JavaScript format HTTP routes mocked in JavaScript using Mock Service Workers HTTP mount points expressed as Mithril mixin components.","title":"ComputePods interface generation design"},{"location":"Generation/#computepods-interface-generation-design","text":"Once the description of an interface has been loaded, the interface generator tool uses Jinja2 templates to generate various interface code files. At the moment the interface generator generates the follow types of code: JSON type definition in Python pydantic format using datamodel-code-generator Consider using the companion fastapi-code-generator JSON example data in Python format JSON type definition in JavaScript formatted using AJV JSON example data in JavaScript format HTTP routes mocked in JavaScript using Mock Service Workers HTTP mount points expressed as Mithril mixin components.","title":"ComputePods interface generation design"},{"location":"InterfaceFormat/","text":"ComputePods interface format The interface format consists of a Markdown file with embedded YAML code blocks. The Markdown structure of the overall description provides the developers with a human readable description of each interface. The embedded YAML code blocks describe sections of the overall interface in a precise machine readable format which is not too difficult for a human developer to read and understand. The outer level of the YAML for an interface consists of a dictionary containing five keys: jsonSchemaPreamble The (optional) jsonSchemaPreamble is a dictionary of the JSON Schema preambles for each of the root classes to be built. The keys in the dictionary associated with each root class consist of the JSON schema preamble definitions for that root class's whole schema. The YAMLized schema for jsonSchemaPreamble is as follows: yaml jsonSchemaPreamble: # is a dictionary of jsonType -> JSON Schema preamble strings type: dictionary items: type: dictionary items: type: string jsonSchemaDefs The jsonSchemaDefs is a dictionary of individual JSON types defined using a YAMLized JSON schema format ( see below ) The YAMLized schema for jsonSchemaDefs is as follows: yaml jsonSchemaDefs: # is a dictionary of jsonType -> JSON Schema definitions type: dictionary items: type: draft7 # A (draft 7) JSON Schema jsonExamples The jsonExamples is a dictionary containing arrays of JSON examples for each major JSON type. These examples can be used in automated testing of the interfaced components. The YAMLized schema for the header of one jsonExamples is as follows: yaml jsonExamplesHeader: # is a dictionary of jsonType -> http route fragments type: object properties: title: type: string httpRoutes: type: object properties: # an httpRoute fragment is a object of: # - an example route (url) # - an action route: type: string action: enum: - GET - POST - PUT - DELETE httpRoutes The httpRoutes is a dictionary of server HTTP mount points. Associated with each mount point is a JSON object with the properties body (which is the name of a jsonType in the jsonSchemaDefs ), url (a string URL template for the mount point), actions (an array of GET , POST , PUT and DELETE HTTP actions). The body jsonType is expected JSON payload and response (if any). Each JSON type MUST be described in the jsonSchemaDefs dictionary. Question : Since the HTTP route orders tend to be significant, should this be an ordered array (or can we simply order the keys)? Answer : We will use a dictionary for the collection of routes, but each route will have a numeric \"priority\" field. The collection of routes will be sorted by priority and then the route (as a string). The YAMLized schema for httpRoutes is as follows: ```yaml httpRoutes: # is a dictionary of mountPoints -> httpRoutes type: dictionary items: # an httpRoute is a dictionary of: # - a list of actions (GET, POST, PUT, DELETE) # - a declaration of the request/response body format # as a jsonType in the jsonSchemaDefs # - the url template (which may include <name> elements) # # We follow a RESTful interface guide lines: # See: https://en.wikipedia.org/wiki/Representational_state_transfer#Semantics_of_HTTP_methods # type: object properties: body: # the name of a jsonType in the jsonSchemaDefs type: string url: # the url template for this mount point type: string actions: type: array items: enum: - GET - POST - PUT - DELETE ``` natsChannels The natsChannels is a dictionary of NATS channels. Each channel is a dictionary describing the channel and the type of its expected JSON payloads and responses (if any). Each JSON type MUST be described in the jsonSchemaDefs dictionary. The YAMLized schema for natsChannels is as follows: yaml natsChannels: { } # is a dictionary of NATS channels -> ???? The parsing and validation of the JSON payloads will be done using AJV (for JavaScript) and datamodel-code-generator + pydantic (for Python). YAMLized JSON schema format The YAMLized description of each JSON type is essentially that fragment of the full JSON schema which is needed to define one JSON type. Once processed by the interface generator, the combination of the jsonSchemaPreamble and the jsonSchemaDefs is a JSON schema format sufficient for the use with both AJV and datamodel-code-generator . Once processed into valid JSON schema, the jsonSchemaDefs definitions are placed into a standard JSON schema $defs dictionary. This means the cross references to types defined in this interface schema, can be done using the standard (internal) reference notation: $ref: \"#/$defs/<nameOfJsonType>\" To help express the overall semantic meaning of the jsonSchemaDefs we add a dictionary type to the \"valid\" schema. This dictionary type must have an associated items key. This dictionary type is then transformed into valid JSON schema as suggested by the StackOverflow Dictionary-like JSON schema question. JSON schema resources The JSON schema site itself has a number of very accessible introductions to its schema. Of particular use to us is the Structuring a complex schema chapter which is part of the larger Understanding JSON Schema book. In addition there are the JSON Schema Core , JSON Schema Validation and Relative JSON Pointers specifications. JSON schema keywords The following is a list of the JSON schema keywords which the interface generator tool recognises (there may be other keywords defined by the JSON schema specification which we do not have need to use). preamble keywords : $id, $schema, $vocabulary, annotation keywords : description, title, deprecated, readOnly, writeOnly, examples assertion keywords : type, enum, const, multipleOf, maximum, exclusiveMaximum, minimum, exclusiveMinimum, maxLength, minLength, pattern, maxItems, minItems, uniqueItems, maxContains, minContains, maxProperties, minProperties, required, dependentRequired applicator keywords : $ref Note that this list and categorisation is not definitive.","title":"ComputePods interface format"},{"location":"InterfaceFormat/#computepods-interface-format","text":"The interface format consists of a Markdown file with embedded YAML code blocks. The Markdown structure of the overall description provides the developers with a human readable description of each interface. The embedded YAML code blocks describe sections of the overall interface in a precise machine readable format which is not too difficult for a human developer to read and understand. The outer level of the YAML for an interface consists of a dictionary containing five keys: jsonSchemaPreamble The (optional) jsonSchemaPreamble is a dictionary of the JSON Schema preambles for each of the root classes to be built. The keys in the dictionary associated with each root class consist of the JSON schema preamble definitions for that root class's whole schema. The YAMLized schema for jsonSchemaPreamble is as follows: yaml jsonSchemaPreamble: # is a dictionary of jsonType -> JSON Schema preamble strings type: dictionary items: type: dictionary items: type: string jsonSchemaDefs The jsonSchemaDefs is a dictionary of individual JSON types defined using a YAMLized JSON schema format ( see below ) The YAMLized schema for jsonSchemaDefs is as follows: yaml jsonSchemaDefs: # is a dictionary of jsonType -> JSON Schema definitions type: dictionary items: type: draft7 # A (draft 7) JSON Schema jsonExamples The jsonExamples is a dictionary containing arrays of JSON examples for each major JSON type. These examples can be used in automated testing of the interfaced components. The YAMLized schema for the header of one jsonExamples is as follows: yaml jsonExamplesHeader: # is a dictionary of jsonType -> http route fragments type: object properties: title: type: string httpRoutes: type: object properties: # an httpRoute fragment is a object of: # - an example route (url) # - an action route: type: string action: enum: - GET - POST - PUT - DELETE httpRoutes The httpRoutes is a dictionary of server HTTP mount points. Associated with each mount point is a JSON object with the properties body (which is the name of a jsonType in the jsonSchemaDefs ), url (a string URL template for the mount point), actions (an array of GET , POST , PUT and DELETE HTTP actions). The body jsonType is expected JSON payload and response (if any). Each JSON type MUST be described in the jsonSchemaDefs dictionary. Question : Since the HTTP route orders tend to be significant, should this be an ordered array (or can we simply order the keys)? Answer : We will use a dictionary for the collection of routes, but each route will have a numeric \"priority\" field. The collection of routes will be sorted by priority and then the route (as a string). The YAMLized schema for httpRoutes is as follows: ```yaml httpRoutes: # is a dictionary of mountPoints -> httpRoutes type: dictionary items: # an httpRoute is a dictionary of: # - a list of actions (GET, POST, PUT, DELETE) # - a declaration of the request/response body format # as a jsonType in the jsonSchemaDefs # - the url template (which may include <name> elements) # # We follow a RESTful interface guide lines: # See: https://en.wikipedia.org/wiki/Representational_state_transfer#Semantics_of_HTTP_methods # type: object properties: body: # the name of a jsonType in the jsonSchemaDefs type: string url: # the url template for this mount point type: string actions: type: array items: enum: - GET - POST - PUT - DELETE ``` natsChannels The natsChannels is a dictionary of NATS channels. Each channel is a dictionary describing the channel and the type of its expected JSON payloads and responses (if any). Each JSON type MUST be described in the jsonSchemaDefs dictionary. The YAMLized schema for natsChannels is as follows: yaml natsChannels: { } # is a dictionary of NATS channels -> ???? The parsing and validation of the JSON payloads will be done using AJV (for JavaScript) and datamodel-code-generator + pydantic (for Python).","title":"ComputePods interface format"},{"location":"InterfaceFormat/#yamlized-json-schema-format","text":"The YAMLized description of each JSON type is essentially that fragment of the full JSON schema which is needed to define one JSON type. Once processed by the interface generator, the combination of the jsonSchemaPreamble and the jsonSchemaDefs is a JSON schema format sufficient for the use with both AJV and datamodel-code-generator . Once processed into valid JSON schema, the jsonSchemaDefs definitions are placed into a standard JSON schema $defs dictionary. This means the cross references to types defined in this interface schema, can be done using the standard (internal) reference notation: $ref: \"#/$defs/<nameOfJsonType>\" To help express the overall semantic meaning of the jsonSchemaDefs we add a dictionary type to the \"valid\" schema. This dictionary type must have an associated items key. This dictionary type is then transformed into valid JSON schema as suggested by the StackOverflow Dictionary-like JSON schema question.","title":"YAMLized JSON schema format"},{"location":"InterfaceFormat/#json-schema-resources","text":"The JSON schema site itself has a number of very accessible introductions to its schema. Of particular use to us is the Structuring a complex schema chapter which is part of the larger Understanding JSON Schema book. In addition there are the JSON Schema Core , JSON Schema Validation and Relative JSON Pointers specifications.","title":"JSON schema resources"},{"location":"InterfaceFormat/#json-schema-keywords","text":"The following is a list of the JSON schema keywords which the interface generator tool recognises (there may be other keywords defined by the JSON schema specification which we do not have need to use). preamble keywords : $id, $schema, $vocabulary, annotation keywords : description, title, deprecated, readOnly, writeOnly, examples assertion keywords : type, enum, const, multipleOf, maximum, exclusiveMaximum, minimum, exclusiveMinimum, maxLength, minLength, pattern, maxItems, minItems, uniqueItems, maxContains, minContains, maxProperties, minProperties, required, dependentRequired applicator keywords : $ref Note that this list and categorisation is not definitive.","title":"JSON schema keywords"}]}